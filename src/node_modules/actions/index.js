/* 
Action fetchPhones

Так как у нас подключен в middleware redux-thunk, то мы можем писать асинхронные екшены.
И мы будем для этого использовать async await из es7.

В action поле type - обязательное, остальные можно называть как хочешь
Но лучше писать type, payload (где будут данные) и error (true) если нужен.

*/

// Импортируем все возможные варианты событий
import {
  FETCH_PHONES_START,
  FETCH_PHONES_SUCCESS,
  FETCH_PHONES_FAILURE,

  LOAD_MORE_PHONES_START,
  LOAD_MORE_PHONES_SUCCESS,
  LOAD_MORE_PHONES_FAILURE,

  FETCH_PHONE_BY_ID_START,
  FETCH_PHONE_BY_ID_SUCCESS,
  FETCH_PHONE_BY_ID_FAILURE,

  ADD_PHONE_TO_BASKET
} from 'actionTypes'

import {getRenderedPhonesLength} from 'selectors'
// Импортируем fetchPhones, но с названием fetchPhonesApi
import {
  fetchPhones as fetchPhonesApi,
  loadMorePhones as loadMorePhonesApi,
  fetchPhoneById as fetchPhoneByIdApi
} from 'api'



// Функция асинхронно диспачит action, так возвращает функцию
export const fetchPhones = () => async dispatch => {
    
    // Отслеживаем Action по type
  
  dispatch({ type: FETCH_PHONES_START });

  // Отслеживаем ошибку
  try {
    // Если ошибки нет, возвращаем в payload Promise метода fetchPhonesApi()
    const phones = await fetchPhonesApi();
    dispatch({
        type: FETCH_PHONES_SUCCESS,
        payload: phones
      })
  } catch (err) {
          // Если ошибка, возвращаем FETCH_PHONES_FAILURE
    dispatch({
      type: FETCH_PHONES_FAILURE,
      payload: err,
      error: true
    });
  }
};

// Функция асинхронно диспачит action, так возвращает функцию
// вторым аргументом в екшене получить функцию getState, которая при вызове вернет нам текущий стейт.
export const loadMorePhones = () => async (dispatch, getState) => {
    
    // Переменной присваеваем значение колличества отображенных товаров  
    const offset = getRenderedPhonesLength(getState())
  
    dispatch({type: LOAD_MORE_PHONES_START})
  
    try {
      const phones = await loadMorePhonesApi({offset})
      dispatch({
        type: LOAD_MORE_PHONES_SUCCESS,
        payload: phones
      })
    } catch (err) {
      dispatch({
        type: LOAD_MORE_PHONES_FAILURE,
        payload: err,
        error: true
      })
    }
  }

// Создаемт екшен, передав ему на вход id и вызвав fetchPhoneByIdApi
  export const fetchPhoneById = (id) => async dispatch => {
    dispatch({type: FETCH_PHONE_BY_ID_START})
  
    try {
      const phone = await fetchPhoneByIdApi(id)
      dispatch({
        type: FETCH_PHONE_BY_ID_SUCCESS,
        payload: phone
      })
    } catch (err) {
      dispatch({
        type: FETCH_PHONE_BY_ID_FAILURE,
        payload: err,
        error: true
      })
    }
  }

// Так как сведения не надо грузить из базы, то создаемт синхронный екшен, передав ему на вход id. 
  export const addPhoneToBasket = id => dispatch => {
    dispatch({
      type: ADD_PHONE_TO_BASKET,
      payload: id
    })
  }