/* 
Reducer - Phones

 Ramda -это отличная библиотека в функциональном стиле, где из множества простых функций
 можно строить как из кирпичиков более сложные функции и их использовать.

Мы вызываем функцию Ramda indexBy, которая первым аргументом получает R.prop('id'),
а вторым аргументом наши данные. R.prop мы используем,
чтобы указать какое поле мы хотим видеть как ключ обьекта.

Ramda хороша тем, что все ее функции возвращают новые данные и никогда не мутируют старые.
В случае с redux это особенно важно, так как стейт нельзя мутировать.

*/

// Импортируем Ramda для работы с ID ключами
import R from 'ramda'

import {
  FETCH_PHONES_SUCCESS,
  FETCH_PHONE_BY_ID_SUCCESS,
  LOAD_MORE_PHONES_SUCCESS
} from 'actionTypes'

const initialState = {}

// Используем деструктуризацию {type, payload}
export default (state = initialState, {type, payload}) => {
  // Используем switch-case для отслеживания Action type
  switch (type) {
    // CASE - загрузить все телефоны
    case FETCH_PHONES_SUCCESS:
    //Превращаем массив обьектов в обьект с ключами методом indexBy
    const newValues = R.indexBy(R.prop('id'), payload); //id - ключ объекта

    // Возвращаем слияние State с полученными данными из payload с ключами
    return R.merge(state, newValues);

    // CASE - загрузить еще
    case LOAD_MORE_PHONES_SUCCESS:
      const moreValues = R.indexBy(R.prop('id'), payload)
      return R.merge(state, moreValues)
    
      // CASE - найти телефон по ID
      case FETCH_PHONE_BY_ID_SUCCESS:
      /* Для того, чтобы добавить в обьект новый ключ, 
      мы можем использовать метод Ramda assoc. 
      Первым параметром идет ключ, а вторым значение. 
      Третьим параметром идет наш state.*/
      return R.assoc(payload.id, payload, state)

    // если case не подходит, то возвращаем state
    default:
      return state
  }  
}




